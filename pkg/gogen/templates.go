/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
    http://www.apache.org/licenses/LICENSE-2.0
*/

package gogen

import (
	"strings"
	"text/template"
)

var templateFuncMap template.FuncMap = template.FuncMap{
	"lc":                    strings.ToLower,
	"camelToSnake":          camelToSnake,
	"defaultCode":           defaultCode,
	"ucFirst":               ucFirst,
	"srvNameFromSrvMsgName": srvNameFromSrvMsgName,
	"cReturnCodeNameToGo":   cReturnCodeNameToGo,
	"cloneCode":             cloneCode,
}

var ros2PackageCommonTemplate = template.Must(
	template.New("ros2PackageCommonTemplate").Funcs(templateFuncMap).Parse(
		`/* This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

// Code generated by rclgo-gen. DO NOT EDIT.

package {{ .GoPackage }}

/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -l{{.CPackage}}__rosidl_typesupport_c -l{{.CPackage}}__rosidl_generator_c
{{range $k, $v := .CImports -}}
#cgo LDFLAGS: -l{{$k}}__rosidl_typesupport_c -l{{$k}}__rosidl_generator_c
{{""}}
{{- end}}
#cgo CFLAGS: -I/opt/ros/galactic/include
*/
import "C"
`,
	),
)

var ros2MsgToGolangTypeTemplate = template.Must(
	template.New("ros2MsgToGolangTypeTemplate").Funcs(templateFuncMap).Parse(
		`/*{{ $Md := .Message }}
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

// Code generated by rclgo-gen. DO NOT EDIT.

package {{ $Md.GoPackage }}
import (
	"unsafe"

	"{{.Config.RclgoImportPath}}/pkg/rclgo"
	"{{.Config.RclgoImportPath}}/pkg/rclgo/types"
	"{{.Config.RclgoImportPath}}/pkg/rclgo/typemap"
	{{range $path, $name := $Md.GoImports -}}
	{{$name}} "{{$path}}"
	{{""}}{{- end}}
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>
{{if eq $Md.Type "msg"}}
#include <{{$Md.Package}}/msg/{{$Md.Name | camelToSnake}}.h>
{{else if eq $Md.Type "srv"}}
#include <{{$Md.Package}}/srv/{{$Md.Name | srvNameFromSrvMsgName | camelToSnake}}.h>
{{end}}
*/
import "C"

func init() {
	typemap.RegisterMessage("{{$Md.Package}}/{{$Md.Name}}", {{$Md.Name}}TypeSupport)
}

{{- if $Md.Constants }}
const (
{{- range $Md.Constants }}
	{{$Md.Name}}_{{.RosName}} {{.GoPkgReference}}{{.GoType}} = {{.Value}}{{if .Comment -}} // {{.Comment}}{{- end}}
{{- end }}
)
{{- end }}

// Do not create instances of this type directly. Always use New{{$Md.Name}}
// function instead.
type {{$Md.Name}} struct {
	{{- range $k, $v := $Md.Fields }}
	{{$v.GoName }} {{$v.TypeArray}}{{$v.GoPkgReference}}{{$v.GoType}}` +
			"{{\"\"}} `yaml:\"{{$v.RosName}}\"`" + `{{if .Comment -}} // {{.Comment}}{{- end}}
	{{- end }}
}

// New{{$Md.Name}} creates a new {{$Md.Name}} with default values.
func New{{$Md.Name}}() *{{$Md.Name}} {
	self := {{$Md.Name}}{}
	self.SetDefaults()
	return &self
}

func (t *{{$Md.Name}}) Clone() *{{$Md.Name}} {
	c := &{{$Md.Name}}{}
	{{- range $f := $Md.Fields }}
	{{cloneCode $f}}
	{{- end }}
	return c
}

func (t *{{$Md.Name}}) CloneMsg() types.Message {
	return t.Clone()
}

func (t *{{$Md.Name}}) SetDefaults() {
	{{- range $k, $v := $Md.Fields }}
	{{defaultCode $v}}
	{{- end }}
}

// {{$Md.Name}}Publisher wraps rclgo.Publisher to provide type safe helper
// functions
type {{$Md.Name}}Publisher struct {
	*rclgo.Publisher
}

// New{{$Md.Name}}Publisher creates and returns a new publisher for the
// {{$Md.Name}}
func New{{$Md.Name}}Publisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*{{$Md.Name}}Publisher, error) {
	pub, err := node.NewPublisher(topic_name, {{$Md.Name}}TypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &{{$Md.Name}}Publisher{pub}, nil
}

func (p *{{$Md.Name}}Publisher) Publish(msg *{{$Md.Name}}) error {
	return p.Publisher.Publish(msg)
}

// {{$Md.Name}}Subscription wraps rclgo.Subscription to provide type safe helper
// functions
type {{$Md.Name}}Subscription struct {
	*rclgo.Subscription
}

// {{$Md.Name}}SubscriptionCallback type is used to provide a subscription
// handler function for a {{$Md.Name}}Subscription.
type {{$Md.Name}}SubscriptionCallback func(msg *{{$Md.Name}}, info *rclgo.RmwMessageInfo, err error)

// New{{$Md.Name}}Subscription creates and returns a new subscription for the
// {{$Md.Name}}
func New{{$Md.Name}}Subscription(node *rclgo.Node, topic_name string, subscriptionCallback {{$Md.Name}}SubscriptionCallback) (*{{$Md.Name}}Subscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg {{$Md.Name}}
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, {{$Md.Name}}TypeSupport, callback)
	if err != nil {
		return nil, err
	}
	return &{{$Md.Name}}Subscription{sub}, nil
}

func (s *{{$Md.Name}}Subscription) TakeMessage(out *{{$Md.Name}}) (*rclgo.RmwMessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}


// Clone{{$Md.Name}}Slice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func Clone{{$Md.Name}}Slice(dst, src []{{$Md.Name}}) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var {{$Md.Name}}TypeSupport types.MessageTypeSupport = _{{$Md.Name}}TypeSupport{}

type _{{$Md.Name}}TypeSupport struct{}

func (t _{{$Md.Name}}TypeSupport) New() types.Message {
	return New{{$Md.Name}}()
}

func (t _{{$Md.Name}}TypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}
	return (unsafe.Pointer)(C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__create())
}

func (t _{{$Md.Name}}TypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__destroy((*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(pointer_to_free))
}

func (t _{{$Md.Name}}TypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	{{ if $Md.Fields -}}
	m := msg.(*{{$Md.Name}})
	mem := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(dst)
	{{- range $Md.Fields }}
	{{call $.cSerializationCode . $Md}}
	{{- end }}
	{{- end }}
}

func (t _{{$Md.Name}}TypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	{{if $Md.Fields -}}
	m := msg.(*{{$Md.Name}})
	mem := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(ros2_message_buffer)
	{{- range $Md.Fields }}
	{{call $.goSerializationCode . $Md}}
	{{- end }}
	{{- end }}
}

func (t _{{$Md.Name}}TypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}())
}

type C{{$Md.Name}} = C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}
type C{{$Md.Name}}__Sequence = C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__Sequence

func {{$Md.Name}}__Sequence_to_Go(goSlice *[]{{$Md.Name}}, cSlice C{{$Md.Name}}__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]{{$Md.Name}}, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}}__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}} * uintptr(i)),
		))
		{{$Md.Name}}TypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(cIdx))
	}
}
func {{$Md.Name}}__Sequence_to_C(cSlice *C{{$Md.Name}}__Sequence, goSlice []{{$Md.Name}}) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(C.malloc((C.size_t)(C.sizeof_struct_{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}} * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}})(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_{{$Md.Package}}__{{$Md.Type}}__{{$Md.Name}} * uintptr(i)),
		))
		{{$Md.Name}}TypeSupport.AsCStruct(unsafe.Pointer(cIdx), &v)
	}
}
func {{$Md.Name}}__Array_to_Go(goSlice []{{$Md.Name}}, cSlice []C{{$Md.Name}}) {
	for i := 0; i < len(cSlice); i++ {
		{{$Md.Name}}TypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func {{$Md.Name}}__Array_to_C(cSlice []C{{$Md.Name}}, goSlice []{{$Md.Name}}) {
	for i := 0; i < len(goSlice); i++ {
		{{$Md.Name}}TypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
`),
)

var ros2ServiceToGolangTypeTemplate = template.Must(
	template.New("ros2ServiceToGolangTypeTemplate").
		Funcs(templateFuncMap).
		Parse(
			`/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

// Code generated by rclgo-gen. DO NOT EDIT.

package {{ .Service.GoPackage }}

/*
#include <rosidl_runtime_c/message_type_support_struct.h>
#include <{{.Service.Package}}/srv/{{.Service.Name | camelToSnake}}.h>
*/
import "C"

import (
	"context"
	"errors"
	"unsafe"

	"{{.Config.RclgoImportPath}}/pkg/rclgo"
	"{{.Config.RclgoImportPath}}/pkg/rclgo/typemap"
	"{{.Config.RclgoImportPath}}/pkg/rclgo/types"
)

func init() {
	typemap.RegisterService("{{.Service.Package}}/{{.Service.Name}}", {{ .Service.Name }}TypeSupport)
}

type _{{.Service.Name}}TypeSupport struct {}

func (s _{{.Service.Name}}TypeSupport) Request() types.MessageTypeSupport {
	return {{.Service.Request.Name}}TypeSupport
}

func (s _{{.Service.Name}}TypeSupport) Response() types.MessageTypeSupport {
	return {{.Service.Response.Name}}TypeSupport
}

func (s _{{.Service.Name}}TypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_service_type_support_handle__{{.Service.Package}}__{{.Service.Type}}__{{.Service.Name}}())
}

// Modifying this variable is undefined behavior.
var {{ .Service.Name }}TypeSupport types.ServiceTypeSupport = _{{.Service.Name}}TypeSupport{}

// {{.Service.Name}}Client wraps rclgo.Client to provide type safe helper
// functions
type {{.Service.Name}}Client struct {
	*rclgo.Client
}

// New{{.Service.Name}}Client creates and returns a new client for the
// {{.Service.Name}}
func New{{.Service.Name}}Client(node *rclgo.Node, serviceName string, options *rclgo.ClientOptions) (*{{.Service.Name}}Client, error) {
	client, err := node.NewClient(serviceName, {{.Service.Name}}TypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &{{.Service.Name}}Client{client}, nil
}

func (s *{{.Service.Name}}Client) Send(ctx context.Context, req *{{.Service.Request.Name}}) (*{{.Service.Response.Name}}, *rclgo.RmwServiceInfo, error) {
	msg, rmw, err := s.Client.Send(ctx, req)
	if err != nil {
		return nil, rmw, err
	}
	typedMessage, ok := msg.(*{{.Service.Response.Name}})
	if !ok {
		return nil, rmw, errors.New("invalid message type returned")
	}
	return typedMessage, rmw, err
}

type {{.Service.Name}}ServiceResponseSender struct {
	sender rclgo.ServiceResponseSender
}

func (s {{.Service.Name}}ServiceResponseSender) SendResponse(resp *{{.Service.Response.Name}}) error {
	return s.sender.SendResponse(resp)
}

type {{.Service.Name}}ServiceRequestHandler func(*rclgo.RmwServiceInfo, *{{.Service.Request.Name}}, {{.Service.Name}}ServiceResponseSender)

// {{.Service.Name}}Service wraps rclgo.Service to provide type safe helper
// functions
type {{.Service.Name}}Service struct {
	*rclgo.Service
}

// New{{.Service.Name}}Service creates and returns a new service for the
// {{.Service.Name}}
func New{{.Service.Name}}Service(node *rclgo.Node, name string, options *rclgo.ServiceOptions, handler {{.Service.Name}}ServiceRequestHandler) (*{{.Service.Name}}Service, error) {
	h := func(rmw *rclgo.RmwServiceInfo, msg types.Message, rs rclgo.ServiceResponseSender) {
		m := msg.(*{{.Service.Request.Name}})
		responseSender := {{.Service.Name}}ServiceResponseSender{sender: rs} 
		handler(rmw, m, responseSender)
	}
	service, err := node.NewService(name, {{.Service.Name}}TypeSupport, options, h)
	if err != nil {
		return nil, err
	}
	return &{{.Service.Name}}Service{service}, nil
}

`),
)

var primitiveTypes = template.Must(
	template.New("primitiveTypes").Funcs(templateFuncMap).Parse(
		`/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

// Code generated by rclgo-gen. DO NOT EDIT.

package primitives

/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo CFLAGS: -I/opt/ros/galactic/include

#include "rosidl_runtime_c/string.h"
#include "rosidl_runtime_c/primitives_sequence.h"

*/
import "C"
import (
	"unsafe"
){{range $k, $v := .PMap -}}{{if .SkipAutogen}}{{- else -}}
{{""}}
{{""}}
// {{.RosType | ucFirst}}
type C{{.RosType | ucFirst}} = C.{{.CType}}
type C{{.RosType | ucFirst}}__Sequence = C.rosidl_runtime_c__{{.CStructName}}__Sequence

func {{.RosType | ucFirst}}__Sequence_to_Go(goSlice *[]{{.GoType}}, cSlice C{{.RosType | ucFirst}}__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]{{.GoType}}, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.{{.CType}})(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_{{.CType}} * uintptr(i)),
		))
		(*goSlice)[i] = {{.GoType}}(*cIdx)
	}
}
func {{.RosType | ucFirst}}__Sequence_to_C(cSlice *C{{.RosType | ucFirst}}__Sequence, goSlice []{{.GoType}}) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.{{.CType}})(C.malloc((C.size_t)(C.sizeof_{{.CType}} * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.{{.CType}})(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_{{.CType}} * uintptr(i)),
		))
		*cIdx = (C.{{.CType}})(v)
	}
}
func {{.RosType | ucFirst}}__Array_to_Go(goSlice []{{.GoType}}, cSlice []C{{.RosType | ucFirst}}) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i] = {{.GoType}}(cSlice[i])
	}
}
func {{.RosType | ucFirst}}__Array_to_C(cSlice []C{{.RosType | ucFirst}}, goSlice []{{.GoType}}) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = C.{{.CType}}(goSlice[i])
	}
}
{{- end}}{{- end}}
`),
)

var ros2MsgImportAllPackage = template.Must(
	template.New("ros2MsgToGolangTypeTemplate").Funcs(templateFuncMap).Parse(
		`/*
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

// Code generated by rclgo-gen. DO NOT EDIT.

package msgs

import (
	{{- range $import, $unused := .Packages }}
	_ "{{$.Config.MessageModulePrefix}}/{{$import}}" //
	{{- end }}
)
`),
)

var ros2ErrorCodes = template.Must(
	template.New("ros2ErrorCodes").Funcs(templateFuncMap).Parse(
		`/*{{ $P := . }}
This file is part of rclgo

Copyright © 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

// Code generated by rclgo-gen. DO NOT EDIT.

package rclgo

/*
#include <rcl/types.h>
#include <rmw/ret_types.h>
*/
import "C"
import (
	"runtime"
)

func errorsCastC(rcl_ret_t C.rcl_ret_t, context string) error {
	stackTraceBuffer := make([]byte, 2048)
	runtime.Stack(stackTraceBuffer, false) // Get stack trace of the current running thread only

	// https://stackoverflow.com/questions/9928221/table-of-functions-vs-switch-in-golang
	// switch-case is faster thanks to compiler optimization than a dispatcher?
	switch rcl_ret_t {
	{{range $e := .ERRORS -}}{{if $e.Rcl_ret_t -}}{{if not (index $P.DEDUP_FILTER $e.Name) -}}
	case C.{{$e.Name}}:
		return &{{$e.Name|cReturnCodeNameToGo}}{rclRetStruct: rclRetStruct{rclRetCode: {{$e.Rcl_ret_t}}, trace: string(stackTraceBuffer), context: errorsBuildContext(&{{$e.Name|cReturnCodeNameToGo}}{}, context, string(stackTraceBuffer))}}
	{{""}}
	{{- end}}{{- end}}{{- end}}
	default:
		return &UnknownReturnCode{rclRetStruct: rclRetStruct{rclRetCode: int(rcl_ret_t), context: context}}
	}
}

type UnknownReturnCode struct {
	rclRetStruct
}

{{range $e := .ERRORS -}}{{if $e.Rcl_ret_t}}
// {{$e.Name|cReturnCodeNameToGo}} {{$e.Comment}}
type {{$e.Name|cReturnCodeNameToGo}} struct {
	rclRetStruct
}
{{""}}
{{- end}}{{- end}}

{{range $e := .ERRORS -}}{{if $e.Reference}}
// {{$e.Name|cReturnCodeNameToGo}} {{$e.Comment}}
type {{$e.Name|cReturnCodeNameToGo}} = {{$e.Reference|cReturnCodeNameToGo}}
{{""}}
{{- end}}{{- end}}

`),
)
