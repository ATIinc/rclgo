/*
This file is part of rclgo

Copyright Â© 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package px4_msgs
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/ros2/ros2types"
	"github.com/tiiuae/rclgo/pkg/ros2/ros2_type_dispatcher"
	
)
/*
#cgo LDFLAGS: -L/opt/ros/foxy/lib -Wl,-rpath=/opt/ros/foxy/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -lpx4_msgs__rosidl_typesupport_c -lpx4_msgs__rosidl_generator_c

#cgo CFLAGS: -I/opt/ros/foxy/include

#include <rosidl_runtime_c/message_type_support_struct.h>
#include <px4_msgs/msg/estimator_status_flags.h>
*/
import "C"

func init() {
	ros2_type_dispatcher.RegisterROS2MsgTypeNameAlias("px4_msgs/EstimatorStatusFlags", &EstimatorStatusFlags{})
}

// Do not create instances of this type directly. Always use NewEstimatorStatusFlags
// function instead.
type EstimatorStatusFlags struct {
	Timestamp uint64 `yaml:"timestamp"`// time since system start (microseconds)
	TimestampSample uint64 `yaml:"timestamp_sample"`// the timestamp of the raw data (microseconds)
	ControlStatusChanges uint32 `yaml:"control_status_changes"`// number of filter control status (cs) changes. filter control status
	CsTiltAlign bool `yaml:"cs_tilt_align"`// 0 - true if the filter tilt alignment is complete. filter control status
	CsYawAlign bool `yaml:"cs_yaw_align"`// 1 - true if the filter yaw alignment is complete. filter control status
	CsGps bool `yaml:"cs_gps"`// 2 - true if GPS measurement fusion is intended. filter control status
	CsOptFlow bool `yaml:"cs_opt_flow"`// 3 - true if optical flow measurements fusion is intended. filter control status
	CsMagHdg bool `yaml:"cs_mag_hdg"`// 4 - true if a simple magnetic yaw heading fusion is intended. filter control status
	CsMag3d bool `yaml:"cs_mag_3d"`// 5 - true if 3-axis magnetometer measurement fusion is inteded. filter control status
	CsMagDec bool `yaml:"cs_mag_dec"`// 6 - true if synthetic magnetic declination measurements fusion is intended. filter control status
	CsInAir bool `yaml:"cs_in_air"`// 7 - true when the vehicle is airborne. filter control status
	CsWind bool `yaml:"cs_wind"`// 8 - true when wind velocity is being estimated. filter control status
	CsBaroHgt bool `yaml:"cs_baro_hgt"`// 9 - true when baro height is being fused as a primary height reference. filter control status
	CsRngHgt bool `yaml:"cs_rng_hgt"`// 10 - true when range finder height is being fused as a primary height reference. filter control status
	CsGpsHgt bool `yaml:"cs_gps_hgt"`// 11 - true when GPS height is being fused as a primary height reference. filter control status
	CsEvPos bool `yaml:"cs_ev_pos"`// 12 - true when local position data fusion from external vision is intended. filter control status
	CsEvYaw bool `yaml:"cs_ev_yaw"`// 13 - true when yaw data from external vision measurements fusion is intended. filter control status
	CsEvHgt bool `yaml:"cs_ev_hgt"`// 14 - true when height data from external vision measurements is being fused. filter control status
	CsFuseBeta bool `yaml:"cs_fuse_beta"`// 15 - true when synthetic sideslip measurements are being fused. filter control status
	CsMagFieldDisturbed bool `yaml:"cs_mag_field_disturbed"`// 16 - true when the mag field does not match the expected strength. filter control status
	CsFixedWing bool `yaml:"cs_fixed_wing"`// 17 - true when the vehicle is operating as a fixed wing vehicle. filter control status
	CsMagFault bool `yaml:"cs_mag_fault"`// 18 - true when the magnetometer has been declared faulty and is no longer being used. filter control status
	CsFuseAspd bool `yaml:"cs_fuse_aspd"`// 19 - true when airspeed measurements are being fused. filter control status
	CsGndEffect bool `yaml:"cs_gnd_effect"`// 20 - true when protection from ground effect induced static pressure rise is active. filter control status
	CsRngStuck bool `yaml:"cs_rng_stuck"`// 21 - true when rng data wasn't ready for more than 10s and new rng values haven't changed enough. filter control status
	CsGpsYaw bool `yaml:"cs_gps_yaw"`// 22 - true when yaw (not ground course) data fusion from a GPS receiver is intended. filter control status
	CsMagAlignedInFlight bool `yaml:"cs_mag_aligned_in_flight"`// 23 - true when the in-flight mag field alignment has been completed. filter control status
	CsEvVel bool `yaml:"cs_ev_vel"`// 24 - true when local frame velocity data fusion from external vision measurements is intended. filter control status
	CsSyntheticMagZ bool `yaml:"cs_synthetic_mag_z"`// 25 - true when we are using a synthesized measurement for the magnetometer Z component. filter control status
	CsVehicleAtRest bool `yaml:"cs_vehicle_at_rest"`// 26 - true when the vehicle is at rest. filter control status
	FaultStatusChanges uint32 `yaml:"fault_status_changes"`// number of filter fault status (fs) changes. fault status
	FsBadMagX bool `yaml:"fs_bad_mag_x"`// 0 - true if the fusion of the magnetometer X-axis has encountered a numerical error. fault status
	FsBadMagY bool `yaml:"fs_bad_mag_y"`// 1 - true if the fusion of the magnetometer Y-axis has encountered a numerical error. fault status
	FsBadMagZ bool `yaml:"fs_bad_mag_z"`// 2 - true if the fusion of the magnetometer Z-axis has encountered a numerical error. fault status
	FsBadHdg bool `yaml:"fs_bad_hdg"`// 3 - true if the fusion of the heading angle has encountered a numerical error. fault status
	FsBadMagDecl bool `yaml:"fs_bad_mag_decl"`// 4 - true if the fusion of the magnetic declination has encountered a numerical error. fault status
	FsBadAirspeed bool `yaml:"fs_bad_airspeed"`// 5 - true if fusion of the airspeed has encountered a numerical error. fault status
	FsBadSideslip bool `yaml:"fs_bad_sideslip"`// 6 - true if fusion of the synthetic sideslip constraint has encountered a numerical error. fault status
	FsBadOptflowX bool `yaml:"fs_bad_optflow_x"`// 7 - true if fusion of the optical flow X axis has encountered a numerical error. fault status
	FsBadOptflowY bool `yaml:"fs_bad_optflow_y"`// 8 - true if fusion of the optical flow Y axis has encountered a numerical error. fault status
	FsBadVelN bool `yaml:"fs_bad_vel_n"`// 9 - true if fusion of the North velocity has encountered a numerical error. fault status
	FsBadVelE bool `yaml:"fs_bad_vel_e"`// 10 - true if fusion of the East velocity has encountered a numerical error. fault status
	FsBadVelD bool `yaml:"fs_bad_vel_d"`// 11 - true if fusion of the Down velocity has encountered a numerical error. fault status
	FsBadPosN bool `yaml:"fs_bad_pos_n"`// 12 - true if fusion of the North position has encountered a numerical error. fault status
	FsBadPosE bool `yaml:"fs_bad_pos_e"`// 13 - true if fusion of the East position has encountered a numerical error. fault status
	FsBadPosD bool `yaml:"fs_bad_pos_d"`// 14 - true if fusion of the Down position has encountered a numerical error. fault status
	FsBadAccBias bool `yaml:"fs_bad_acc_bias"`// 15 - true if bad delta velocity bias estimates have been detected. fault status
	FsBadAccVertical bool `yaml:"fs_bad_acc_vertical"`// 16 - true if bad vertical accelerometer data has been detected. fault status
	FsBadAccClipping bool `yaml:"fs_bad_acc_clipping"`// 17 - true if delta velocity data contains clipping (asymmetric railing). fault status
	InnovationFaultStatusChanges uint32 `yaml:"innovation_fault_status_changes"`// number of innovation fault status (reject) changes. innovation test failures
	RejectHorVel bool `yaml:"reject_hor_vel"`// 0 - true if horizontal velocity observations have been rejected. innovation test failures
	RejectVerVel bool `yaml:"reject_ver_vel"`// 1 - true if vertical velocity observations have been rejected. innovation test failures
	RejectHorPos bool `yaml:"reject_hor_pos"`// 2 - true if horizontal position observations have been rejected. innovation test failures
	RejectVerPos bool `yaml:"reject_ver_pos"`// 3 - true if vertical position observations have been rejected. innovation test failures
	RejectMagX bool `yaml:"reject_mag_x"`// 4 - true if the X magnetometer observation has been rejected. innovation test failures
	RejectMagY bool `yaml:"reject_mag_y"`// 5 - true if the Y magnetometer observation has been rejected. innovation test failures
	RejectMagZ bool `yaml:"reject_mag_z"`// 6 - true if the Z magnetometer observation has been rejected. innovation test failures
	RejectYaw bool `yaml:"reject_yaw"`// 7 - true if the yaw observation has been rejected. innovation test failures
	RejectAirspeed bool `yaml:"reject_airspeed"`// 8 - true if the airspeed observation has been rejected. innovation test failures
	RejectSideslip bool `yaml:"reject_sideslip"`// 9 - true if the synthetic sideslip observation has been rejected. innovation test failures
	RejectHagl bool `yaml:"reject_hagl"`// 10 - true if the height above ground observation has been rejected. innovation test failures
	RejectOptflowX bool `yaml:"reject_optflow_x"`// 11 - true if the X optical flow observation has been rejected. innovation test failures
	RejectOptflowY bool `yaml:"reject_optflow_y"`// 12 - true if the Y optical flow observation has been rejected. innovation test failures
}

// NewEstimatorStatusFlags creates a new EstimatorStatusFlags with default values.
func NewEstimatorStatusFlags() *EstimatorStatusFlags {
	self := EstimatorStatusFlags{}
	self.SetDefaults(nil)
	return &self
}

func (t *EstimatorStatusFlags) SetDefaults(d interface{}) ros2types.ROS2Msg {
	
	return t
}

func (t *EstimatorStatusFlags) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__px4_msgs__msg__EstimatorStatusFlags())
}
func (t *EstimatorStatusFlags) PrepareMemory() unsafe.Pointer { //returns *C.px4_msgs__msg__EstimatorStatusFlags
	return (unsafe.Pointer)(C.px4_msgs__msg__EstimatorStatusFlags__create())
}
func (t *EstimatorStatusFlags) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.px4_msgs__msg__EstimatorStatusFlags__destroy((*C.px4_msgs__msg__EstimatorStatusFlags)(pointer_to_free))
}
func (t *EstimatorStatusFlags) AsCStruct() unsafe.Pointer {
	mem := (*C.px4_msgs__msg__EstimatorStatusFlags)(t.PrepareMemory())
	mem.timestamp = C.uint64_t(t.Timestamp)
	mem.timestamp_sample = C.uint64_t(t.TimestampSample)
	mem.control_status_changes = C.uint32_t(t.ControlStatusChanges)
	mem.cs_tilt_align = C.bool(t.CsTiltAlign)
	mem.cs_yaw_align = C.bool(t.CsYawAlign)
	mem.cs_gps = C.bool(t.CsGps)
	mem.cs_opt_flow = C.bool(t.CsOptFlow)
	mem.cs_mag_hdg = C.bool(t.CsMagHdg)
	mem.cs_mag_3d = C.bool(t.CsMag3d)
	mem.cs_mag_dec = C.bool(t.CsMagDec)
	mem.cs_in_air = C.bool(t.CsInAir)
	mem.cs_wind = C.bool(t.CsWind)
	mem.cs_baro_hgt = C.bool(t.CsBaroHgt)
	mem.cs_rng_hgt = C.bool(t.CsRngHgt)
	mem.cs_gps_hgt = C.bool(t.CsGpsHgt)
	mem.cs_ev_pos = C.bool(t.CsEvPos)
	mem.cs_ev_yaw = C.bool(t.CsEvYaw)
	mem.cs_ev_hgt = C.bool(t.CsEvHgt)
	mem.cs_fuse_beta = C.bool(t.CsFuseBeta)
	mem.cs_mag_field_disturbed = C.bool(t.CsMagFieldDisturbed)
	mem.cs_fixed_wing = C.bool(t.CsFixedWing)
	mem.cs_mag_fault = C.bool(t.CsMagFault)
	mem.cs_fuse_aspd = C.bool(t.CsFuseAspd)
	mem.cs_gnd_effect = C.bool(t.CsGndEffect)
	mem.cs_rng_stuck = C.bool(t.CsRngStuck)
	mem.cs_gps_yaw = C.bool(t.CsGpsYaw)
	mem.cs_mag_aligned_in_flight = C.bool(t.CsMagAlignedInFlight)
	mem.cs_ev_vel = C.bool(t.CsEvVel)
	mem.cs_synthetic_mag_z = C.bool(t.CsSyntheticMagZ)
	mem.cs_vehicle_at_rest = C.bool(t.CsVehicleAtRest)
	mem.fault_status_changes = C.uint32_t(t.FaultStatusChanges)
	mem.fs_bad_mag_x = C.bool(t.FsBadMagX)
	mem.fs_bad_mag_y = C.bool(t.FsBadMagY)
	mem.fs_bad_mag_z = C.bool(t.FsBadMagZ)
	mem.fs_bad_hdg = C.bool(t.FsBadHdg)
	mem.fs_bad_mag_decl = C.bool(t.FsBadMagDecl)
	mem.fs_bad_airspeed = C.bool(t.FsBadAirspeed)
	mem.fs_bad_sideslip = C.bool(t.FsBadSideslip)
	mem.fs_bad_optflow_x = C.bool(t.FsBadOptflowX)
	mem.fs_bad_optflow_y = C.bool(t.FsBadOptflowY)
	mem.fs_bad_vel_n = C.bool(t.FsBadVelN)
	mem.fs_bad_vel_e = C.bool(t.FsBadVelE)
	mem.fs_bad_vel_d = C.bool(t.FsBadVelD)
	mem.fs_bad_pos_n = C.bool(t.FsBadPosN)
	mem.fs_bad_pos_e = C.bool(t.FsBadPosE)
	mem.fs_bad_pos_d = C.bool(t.FsBadPosD)
	mem.fs_bad_acc_bias = C.bool(t.FsBadAccBias)
	mem.fs_bad_acc_vertical = C.bool(t.FsBadAccVertical)
	mem.fs_bad_acc_clipping = C.bool(t.FsBadAccClipping)
	mem.innovation_fault_status_changes = C.uint32_t(t.InnovationFaultStatusChanges)
	mem.reject_hor_vel = C.bool(t.RejectHorVel)
	mem.reject_ver_vel = C.bool(t.RejectVerVel)
	mem.reject_hor_pos = C.bool(t.RejectHorPos)
	mem.reject_ver_pos = C.bool(t.RejectVerPos)
	mem.reject_mag_x = C.bool(t.RejectMagX)
	mem.reject_mag_y = C.bool(t.RejectMagY)
	mem.reject_mag_z = C.bool(t.RejectMagZ)
	mem.reject_yaw = C.bool(t.RejectYaw)
	mem.reject_airspeed = C.bool(t.RejectAirspeed)
	mem.reject_sideslip = C.bool(t.RejectSideslip)
	mem.reject_hagl = C.bool(t.RejectHagl)
	mem.reject_optflow_x = C.bool(t.RejectOptflowX)
	mem.reject_optflow_y = C.bool(t.RejectOptflowY)
	return unsafe.Pointer(mem)
}
func (t *EstimatorStatusFlags) AsGoStruct(ros2_message_buffer unsafe.Pointer) {
	mem := (*C.px4_msgs__msg__EstimatorStatusFlags)(ros2_message_buffer)
	t.Timestamp = uint64(mem.timestamp)
	t.TimestampSample = uint64(mem.timestamp_sample)
	t.ControlStatusChanges = uint32(mem.control_status_changes)
	t.CsTiltAlign = bool(mem.cs_tilt_align)
	t.CsYawAlign = bool(mem.cs_yaw_align)
	t.CsGps = bool(mem.cs_gps)
	t.CsOptFlow = bool(mem.cs_opt_flow)
	t.CsMagHdg = bool(mem.cs_mag_hdg)
	t.CsMag3d = bool(mem.cs_mag_3d)
	t.CsMagDec = bool(mem.cs_mag_dec)
	t.CsInAir = bool(mem.cs_in_air)
	t.CsWind = bool(mem.cs_wind)
	t.CsBaroHgt = bool(mem.cs_baro_hgt)
	t.CsRngHgt = bool(mem.cs_rng_hgt)
	t.CsGpsHgt = bool(mem.cs_gps_hgt)
	t.CsEvPos = bool(mem.cs_ev_pos)
	t.CsEvYaw = bool(mem.cs_ev_yaw)
	t.CsEvHgt = bool(mem.cs_ev_hgt)
	t.CsFuseBeta = bool(mem.cs_fuse_beta)
	t.CsMagFieldDisturbed = bool(mem.cs_mag_field_disturbed)
	t.CsFixedWing = bool(mem.cs_fixed_wing)
	t.CsMagFault = bool(mem.cs_mag_fault)
	t.CsFuseAspd = bool(mem.cs_fuse_aspd)
	t.CsGndEffect = bool(mem.cs_gnd_effect)
	t.CsRngStuck = bool(mem.cs_rng_stuck)
	t.CsGpsYaw = bool(mem.cs_gps_yaw)
	t.CsMagAlignedInFlight = bool(mem.cs_mag_aligned_in_flight)
	t.CsEvVel = bool(mem.cs_ev_vel)
	t.CsSyntheticMagZ = bool(mem.cs_synthetic_mag_z)
	t.CsVehicleAtRest = bool(mem.cs_vehicle_at_rest)
	t.FaultStatusChanges = uint32(mem.fault_status_changes)
	t.FsBadMagX = bool(mem.fs_bad_mag_x)
	t.FsBadMagY = bool(mem.fs_bad_mag_y)
	t.FsBadMagZ = bool(mem.fs_bad_mag_z)
	t.FsBadHdg = bool(mem.fs_bad_hdg)
	t.FsBadMagDecl = bool(mem.fs_bad_mag_decl)
	t.FsBadAirspeed = bool(mem.fs_bad_airspeed)
	t.FsBadSideslip = bool(mem.fs_bad_sideslip)
	t.FsBadOptflowX = bool(mem.fs_bad_optflow_x)
	t.FsBadOptflowY = bool(mem.fs_bad_optflow_y)
	t.FsBadVelN = bool(mem.fs_bad_vel_n)
	t.FsBadVelE = bool(mem.fs_bad_vel_e)
	t.FsBadVelD = bool(mem.fs_bad_vel_d)
	t.FsBadPosN = bool(mem.fs_bad_pos_n)
	t.FsBadPosE = bool(mem.fs_bad_pos_e)
	t.FsBadPosD = bool(mem.fs_bad_pos_d)
	t.FsBadAccBias = bool(mem.fs_bad_acc_bias)
	t.FsBadAccVertical = bool(mem.fs_bad_acc_vertical)
	t.FsBadAccClipping = bool(mem.fs_bad_acc_clipping)
	t.InnovationFaultStatusChanges = uint32(mem.innovation_fault_status_changes)
	t.RejectHorVel = bool(mem.reject_hor_vel)
	t.RejectVerVel = bool(mem.reject_ver_vel)
	t.RejectHorPos = bool(mem.reject_hor_pos)
	t.RejectVerPos = bool(mem.reject_ver_pos)
	t.RejectMagX = bool(mem.reject_mag_x)
	t.RejectMagY = bool(mem.reject_mag_y)
	t.RejectMagZ = bool(mem.reject_mag_z)
	t.RejectYaw = bool(mem.reject_yaw)
	t.RejectAirspeed = bool(mem.reject_airspeed)
	t.RejectSideslip = bool(mem.reject_sideslip)
	t.RejectHagl = bool(mem.reject_hagl)
	t.RejectOptflowX = bool(mem.reject_optflow_x)
	t.RejectOptflowY = bool(mem.reject_optflow_y)
}
func (t *EstimatorStatusFlags) Clone() ros2types.ROS2Msg {
	clone := *t
	return &clone
}

type CEstimatorStatusFlags = C.px4_msgs__msg__EstimatorStatusFlags
type CEstimatorStatusFlags__Sequence = C.px4_msgs__msg__EstimatorStatusFlags__Sequence

func EstimatorStatusFlags__Sequence_to_Go(goSlice *[]EstimatorStatusFlags, cSlice CEstimatorStatusFlags__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]EstimatorStatusFlags, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.px4_msgs__msg__EstimatorStatusFlags__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__EstimatorStatusFlags * uintptr(i)),
		))
		(*goSlice)[i] = EstimatorStatusFlags{}
		(*goSlice)[i].AsGoStruct(unsafe.Pointer(cIdx))
	}
}
func EstimatorStatusFlags__Sequence_to_C(cSlice *CEstimatorStatusFlags__Sequence, goSlice []EstimatorStatusFlags) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.px4_msgs__msg__EstimatorStatusFlags)(C.malloc((C.size_t)(C.sizeof_struct_px4_msgs__msg__EstimatorStatusFlags * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.px4_msgs__msg__EstimatorStatusFlags)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_px4_msgs__msg__EstimatorStatusFlags * uintptr(i)),
		))
		*cIdx = *(*C.px4_msgs__msg__EstimatorStatusFlags)(v.AsCStruct())
	}
}
func EstimatorStatusFlags__Array_to_Go(goSlice []EstimatorStatusFlags, cSlice []CEstimatorStatusFlags) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i].AsGoStruct(unsafe.Pointer(&cSlice[i]))
	}
}
func EstimatorStatusFlags__Array_to_C(cSlice []CEstimatorStatusFlags, goSlice []EstimatorStatusFlags) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = *(*C.px4_msgs__msg__EstimatorStatusFlags)(goSlice[i].AsCStruct())
	}
}


